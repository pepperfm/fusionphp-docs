---
title: Introduction
description: Welcome to FusionPHP documentation.
navigation:
  icon: false
---

::u-alert
---
color: error
icon: i-simple-line-icons:info
variant: subtle
title: Caution
---
#description
Fusion is in a very early development preview. Please do not use it in production yet! There are still lots of bugs (probably.)
::

<br />

## Concepts

#### It is important to note up front what Fusion does not do:

::card-group
  :::card
  ---
  icon: i-lucide-cog
  title: No PHP to WASM
  ---
  Fusion does not transpile your PHP into WebAssembly or make it run in the browser.
  :::
  
  :::card
  ---
  icon: i-lucide-code
  title: No JS → Blade
  ---
  Fusion does not turn your JavaScript into Blade or PHP templates.
  :::
  
  :::card
  ---
  icon: i-lucide-file-terminal
  title: No Templating Engine
  ---
  Fusion does not use PHP as a templating engine — HTML and JS stay on the frontend.
  :::
  
  :::card
  ---
  icon: i-lucide-link-2-off
  title: No Auto Sync
  ---
  Fusion does not automatically sync frontend and backend state unless you do it manually.
  :::
::



#### What Fusion does do:

::card-group
  :::card
  ---
  icon: i-lucide-scissors
  title: Extracts PHP Blocks
  ---
  Fusion uses Vite to extract PHP blocks from your JavaScript files and write them to disk.
  :::
  
  :::card
  ---
  icon: i-lucide-inbox
  title: Injects Runtime Info
  ---
  Fusion injects metadata into your JavaScript during the Vite build process.
  :::
  
  :::card
  ---
  icon: i-lucide-server-cog
  title: Dual Runtime
  ---
  PHP runs on the backend, JavaScript on the frontend — clean separation of concerns.
  :::
  
  :::card
  ---
  icon: i-lucide-circuit-board
  title: Controller from Code
  ---
  Transforms your inline PHP block into a backend controller-like unit.
  :::
  
  :::card
  ---
  icon: i-lucide-shield-check
  title: Laravel Native
  ---
  Uses Laravel’s full lifecycle: routing, middleware, request/response, auth, etc.
  :::
  
  :::card
  ---
  icon: i-lucide-refresh-cw
  title: Sync State
  ---
  Allows syncing state between frontend and backend when needed.
  :::
::

## Examples

Conceptually, you can think of the `<php>` block in your file as your controller, with a little bit of auto-wiring applied to inject state and call methods. That's about it! (To learn more, you may read the [how Fusion works](/under-the-hood/how-fusion-works) section.)

Using Fusion, you can write a single file like this:

```php [Procedural.vue]
<php>
$name = prop(auth()->user()->name);
</php>

<template>
  Hello {{ name }}!
</template>
```

This exposes the `$name` variable to your Vue template as `name`. It will be passed down to the frontend upon first load. You do not need to define any props on the Vue side, we take care of that for you.

There are two styles of PHP you can write. You can write "[procedural](/guide/writing-php#procedural-php)" or "[class-based](/guide/writing-php#class-based-php)" PHP.

Procedural is much closer to a functional paradigm, and may feel more comfortable to folks coming from other languages like JavaScript. Writing the previous example using a class-based approach is very similar:

```php [ClassBased.vue]
<php>
  new class {
    public string $name;

    public function mount()
    {
      $this->name = auth()->user()->name;
    }
  }
</php>

<template>
  Hello {{ name }}!
</template>
```

You define a class and all public properties become state.

Neither approach is right, neither is wrong. Neither approach is stupid, neither is smart. It's merely a matter of preference! More details on each approach can be found throughout.
