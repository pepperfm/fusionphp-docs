---
title: Working with JS
description: Learn how to work with your JavaScript.
navigation:
    icon: false
---

You don't have to do anything to receive your state on the frontend, but there is a lot you can do. Because we have a plugin in the Vite toolchain, we're able to add some Vue code to inject the state and actions for you automatically, provided you don't do it yourself.

The automatic process is this simple:
```php
<php>
  new class {
      public string $name = 'Aaron';
  }
</php>

<template>
  Hello {{ name }}
</template>
```
That's it! You do not have to define props, a script tag of any `sort`, or anything else.

::u-alert
---
color: info
icon: i-lucide:notebook-pen
variant: subtle
title: Note
---
#description
We are still working on making your editor aware of these injected pieces of data. More on that soon.
::

If you'd like to define your own script tags, you have as many options as Vue supports.

## A `<script>` tag, without Fusion

You are welcome to define any of the script tags that Vue supports, without referencing Fusion at all. You may use `<script>`, `<script setup>`, or `<script>` with `setup()`. Fusion will inject itself at build time into all of these formats.

For example, a `script setup` tag:
```php
<php>
  new class {
      public string $name = 'Aaron';
  }
</php>

<script setup>
  // Define extra state here? Do something else?
</script>

<template>
  Hello {{ name }}
</template>
```
Or a traditional script tag, with or without a `setup` method:
```php
<php>
  new class {
      public string $name = 'Aaron';
  }
</php>

<script>
  export default {
    setup() {
      // extra setup?
    },
    data() {
      // extra state?
    }
  }
</script>

<template>
  Hello {{ name }}
</template>
```
All of your Fusion state will still be present in your template.

## A `<script setup>` with manual Fusion imports
Alternatively, you may import some or all of the Fusion state yourself by using the `useFusion` function. Every Vue page component gets a corresponding `.js` file from which you can import `useFusion`.
```php
<php>
  new class {
  public string $name = 'Aaron';

  public string $email = 'aaron@example.com';
  }
</php>

<script setup>
  // Assuming this Component is at Pages/Hello.vue, you can 
  // import the shim with the help of the $fusion alias.
  import {useFusion} from "$fusion/Pages/Hello.js";

  // Import `name` only.
  const { name } = useFusion(['name']);
</script>

<template>
  Hello {{ name }}, your email is {{ email }}
</template>
```

In this example, the developer has decided that they want to import the `name` state, and perhaps do something extra with it on the frontend. Because Fusion is aware that the `email` key exists and was not handled by the developer, we'll go ahead and inject just that piece of data.

When you import a piece of state or an action, Fusion gives control of that piece of data over to you.

You can import all of it in one go by not passing anything to the `useFusion` function.

```vue
<script setup>
  import { useFusion } from "$fusion/Pages/Hello.js";

  // Import everything Fusion has to offer.
  const data = useFusion();
</script>
```
If you do this, you'll need to be sure you're exposing your data to the template, if you so desire.

## A `<script>` tag and `setup()` function
If you prefer the options API, you may import the Fusion state in the `setup` function.
```vue
<script setup>
import { useFusion } from "$fusion/Pages/Hello.js";

export default {
  setup() {
    const { name } = useFusion(['name']);

    name.value = 'Steve';

    return { name }
  }
}
</script>
```
In this example, we're importing only the `name` property, leaving any other state to get injected into the template by Fusion. In this example, we (for whatever reason) decided to hardcode the name to `Steve` on the frontend. Notice that at the end we must return the data we want to be exposed.

Remember: if you import it, Fusion hands control to you.
