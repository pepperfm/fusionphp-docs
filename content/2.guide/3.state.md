---
title: State
description: One of the powerful features of Fusion is State. It allows you to sync state without compilation.
navigation:
    icon: false
---

One of Fusion's primary responsibilities is to send your state to the frontend. State is sent at runtime, not compiled into your JavaScript bundle. The only thing that gets written into your bundle are the names of your properties and exposed actions.

## State with Procedural PHP

When using procedural PHP, you can expose a variable to the frontend by using the `Fusion\prop` function.
```php
$name = prop();
```

::tip
This is very non-traditional PHP, and only possible because we're transpiling your PHP code before it gets written to disk. All transpiled PHP is written into your storage directory and you're free to inspect it!
::

By assigning a variable of `$name` to the function `prop`, you've alerted Fusion that `$name` is something that should be shared with the frontend.

### Defaults
You are free to pass in a default value as either a scalar or a Closure.

```php
$name = prop('Aaron');
// Or
$name = prop(fn() => 'Aaron');
```

The default is "Aaron", but if a different value is sent from the frontend, the `$name` variable will be assigned to that value. If the frontend sends `name: "Steve"`, then in your PHP `$name = "Steve"` instead of `Aaron`.

We'll cover syncing state further down.

### Tracking

Something that may feel familiar to a user of a JavaScript framework is that we'll keep track of that variable throughout your code. This will feel strange to most PHP developers:
```php
$name = prop('Aaron');
$name = strtoupper($name);

// "AARON" gets sent to the frontend.
```

We're only able to do this because we are transpiling your code. At the end of the code that you write, we call a Fusion method named `syncProps` passing in `get_defined_vars()`. This gives us the names and values of all of the variables that are in scope. If you've declared a variable as a prop, we will take the last value and use that as the state for the frontend.

### Readonly state

To declare a piece of state "readonly", meaning that you never want to receive it back from the frontend, you can append `->readonly()` to the `prop` function.
```php
$name = prop(Auth::user()->name)->readonly();
```

When `name` gets sent to the frontend, it can still be modified _on the frontend_, if you allow that. But the frontend will never send it to the backend, the backend will _always_ recalculate it.

You can think of this type of state as computed props.
```php
$podcasts = prop(fn() => Podcast::all())->readonly();
```

### Syncing values to the querystring

It may be convenient to sync state to the querystring to create stable URLs. You may do so by appending `->syncQueryString`.
```php
$search = prop()->syncQueryString();
```
By default `$search` is null, but if there is a `?search=` in the URL, that value will be used. If you want the querystring name to be different than the variable name, you may use the `as: ` argument.
```php
$search = prop()->syncQueryString(as: 's');
```
The querystring will now use `?s=` to track this prop.

## State with Class-based PHP
Using class-based PHP, any properties that are `public` will be sent to the frontend. (WIth one caveat, mentioned below.)

Declaring a class like this:
```php
new class 
{
    public string $name = "Aaron";
}
```
will send `name` to your frontend to be consumed.

If you need to hide a `public` property, you may annotate it with `#[Fusion\Attributes\ServerOnly]`. You should rarely need this. If you find yourself needing this often, please open an issue and explain why! We might be able to make it less cumbersome.

Alternatively, you may set the value via the `mount` method to accomplish the same outcome.

Consider the previous class:
```php
new class 
{
    public string $name = "Aaron";
}
```
The default for `$name` is `Aaron`, but if a value comes in from the frontend where `name: "Steve"` then the `$name` variable will be set to `Steve`.

However, if you annotate it with the attribute, it will stay "Aaron".
```php
new class 
{
    #[\Fusion\Attributes\IsReadOnly]
    public string $name = "Aaron";
}
```
Beyond annotating with the `#[IsReadOnly]` attribute, you can just brute-force the value in `mount`:
```php
new class 
{
    public string $name;
    
    public function mount() 
    {
        // Doesn't matter what the frontend sends,
        // we'll just overwrite it.
        $this->name = 'Aaron';
    }
}
```
Now, regardless of what was sent from the frontend, we set the value to `"Aaron"`. You could accomplish a "default" by using the null coalescing operator:
```php
new class 
{
    public ?string $name = null;
    
    public function mount() 
    {
        // Set it to Aaron, only if it's not set.
        $this->name ??= 'Aaron';
    }
}
```
This allows you to potentially sync the `name` state from the frontend, but otherwise assign a default.

### Syncing QueryString
If you'd like to sync a property to the querystring, you may use the `#[SyncQueryString]` attribute.
```php
new class 
{
    #[\Fusion\Attributes\SyncQueryString]
    public string $search = '';
}
```
You're free to pass an `as:` argument to control the name of the querystring:
```php
new class 
{
    #[\Fusion\Attributes\SyncQueryString(as: 's')]
    public string $search = '';
}
```
The variable passed to your frontend will be named `search`, but in the querystring it will appear as `s`.
