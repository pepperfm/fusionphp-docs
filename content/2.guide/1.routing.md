---
title: Routing
description: Learn how to setup your router.
navigation:
    icon: false
---

You have two options when it comes to routing. You may choose to do file-based routing, or route your components individually. You are free to mix and mingle the styles.

## File-based routing

File-based routing is convenient when you want your URL structure to mirror your file structure. To get started with file-based routing, you can call `Fusion::pages()` in your `web.php` file.

```php [web.php]
use Fusion\Fusion;

Fusion::pages();
```

The `pages()` method accepts two arguments: a URI `$root` and a `$directory`. By default, the URI root is `/` and the directory is whatever is defined in your config under `paths.pages`, which is `resources/js/Pages` by default.

By calling `Fusion::pages()` with no arguments, you're saying "route everything in my `fusion.paths.pages` directory, using `/` as the starting point." This includes pages that have no `<php>` block.

By passing arguments, you have more control over the routes. Maybe you only want to auto-route marketing pages, but you want them routed to the root domain.
```php [web.php]
use Fusion\Fusion;

// All pages in resources/js/Pages/Marketing end up at the root.
Fusion::pages(root: '/', directory: 'Marketing');
```

This will route an example component `Marketing/Hello.vue` to the URI `/hello`. You're free to use `pages` as many times as you want:
```php [web.php]
use Fusion\Fusion;

// All marketing pages end up at the root.
Fusion::pages(root: '/', directory: 'Marketing');

// All files in `Cases` end up at `/case-studies`
Fusion::pages(root: '/case-studies', directory: 'Cases');
```

### Route binding

Laravel has powerful [route model binding](https://laravel.com/docs/routing#route-model-binding){target="_blank"}, which allows you to automatically inject models into your controllers instead of having to look them up manually. Fusion exposes that same route model binding.

To indicate that a route has a segment that is a parameter, you may use square brackets [] in the filename.

For example, a file name `Podcasts/[Podcast].vue` would receive a `$podcast` parameter. When a user visits `podcasts/1`, you would receive a string `"1"` as your parameter.

How you receive this parameter depends on the style of PHP you're writing. To receive it in procedural PHP, you may use the `fromRoute()` method on the `prop()` function.

```php
$podcast = prop()->fromRoute();
```

In this example, having not passed any arguments, we will assume that the route's parameter is named `podcast` because your variable was named `$podcast`. Should you need to customize it, you can pass a value:

```php
// Variable is named $pod, but the route parameter is
// `podcast` to match the filename of [Podcast].vue.
$pod = prop()->fromRoute('podcast');
```

Using class-based PHP, you may receive the route parameter in your `mount()` method.

```php
new class {
    public function mount($podcast)
    {
        // Do something with $podcast! Usually that
        // means setting it to a public property.
    }
}
```

When you're using the class-based method of route binding, you actually do not have to include a `mount()` function. If you have a public or protected property that is named the same as a route parameter, we will go ahead and auto set it if there is no `mount()` function available.

```php
new class {
    // Will be set to the route parameter.
    public $podcast;
}
```

### Route model binding

So far, all we've done is route binding, not route model binding. Sometimes route binding is all you want. Most times, you want route model binding. To route model bind, you'll need to tell Fusion what class to look for.

Using procedural PHP

```php
$podcast = prop()->fromRoute(class: \App\Models\Podcast::class);
```
And class-based:

```php
new class {
    // Merely hint the type as a UrlRoutable. 
    public function mount(\App\Models\Podcast $podcast)
    {
        // Podcast is now an Eloquent Model.
    }
}
```

If the model is not found, a 404 error will be thrown.

Again, you can just use a public property instead of using the mount function and we will respect the type hint on that property.

```php
new class {
    public \App\Models\Podcast $podcast;
}
```

To customize the routing even further, you may pass more arguments to the procedural fromRoute method.

```php
$podcast = prop()->fromRoute(
    class: \App\Models\Podcast::class,
    // Route by a custom key instead of `id`
    using: 'slug',
    // Include soft-deleted models. 
    withTrashed: true
);
```

These follow Laravel's standards of including [soft-deleted models](https://laravel.com/docs/routing#implicit-soft-deleted-models){target="_blank"} and customizing the [route key](https://laravel.com/docs/routing#customizing-the-default-key-name){target="_blank"}.

Customization using the class-based mount method is not available yet, but we'll add attributes to control the route key and soft-deletes very soon. Sorry about that!

### Wild-card routes

If you have a route that might have many wildcard segments, you may indicate that with a preceding `...` in the parameter name, like this: `Podcasts/[...wild].vue`.

```php
$wild = prop()->fromRoute();
// $wild === ['the-best', 'show-in-the-world', 'a8f74b']

// Get the unique ID from the parts.
$id = last($wild);
```
```php
new class {
    public function mount(array $wild) 
    {
        $id = last($wild);   
    }
}
```

### Fine-grained control over the routed files

Should you need it, you may exercise greater control over file-based routing by passing a closure as the second argument. The Closure must return an instance of `\Symfony\Component\Finder`.

```php
use Fusion\Fusion;
use Symfony\Component\Finder\Finder;

Fusion::pages('/', fn() => (new Finder)
    // Start in any directory you please.
    ->in(config('fusion.paths.pages'))
    // Some file patterns you don't want routed.
    ->notName('*.template.vue')
    // Maybe we route these separately? Who knows.
    ->exclude([
        'Cases',
        'Marketing'
    ])
);
```

## Manual routing

If you prefer to route your pages one-by-one, you may use the singular page method:
```php [web.php]
use Fusion\Fusion;

Fusion::page(uri: '/hello-world', component: 'Custom/HelloWorld');
```

You are free to combine page() along with pages(). We would suggest putting your page calls first, so that any routes with parameters or wildcards don't take precedence.




[//]: # (### Subtitles)

[//]: # ()
[//]: # (Use subtitles to divide sections further. They create a more detailed content hierarchy for better readability.)

[//]: # ()
[//]: # (::code-preview)

[//]: # (---)

[//]: # (class: "[&>div]:*:my-0")

[//]: # (---)

[//]: # (### Subtitles)

[//]: # ()
[//]: # (#code)

[//]: # (```mdc)

[//]: # (### Subtitles)

[//]: # (```)

[//]: # (::)
